created: 20230131130405023
creator: Gezi
modified: 20230215151223717
modifier: Gezi
tags: 追踪垃圾回收
title: Copying GC
type: text/vnd.tiddlywiki

[img[CopyingGC.png]]
其工作方式是将存活对象从一个内存空间复制到另一个内存空间。

该算法的思路是将所有存活对象移动到一个连续的内存空间，而另一个内存空间留为空。这意味着不需要跟踪或标记对象是存活的还是死亡的，因为此内存空间中的所有对象都被视为死亡。

当第一个内存空间满了，就会触发垃圾回收过程，所有存活对象都将被复制到第二个内存空间。然后，第一个内存空间将被视为空，可用于存储新创建的对象。该过程随着时间的推移继续进行，存活对象将在两个内存空间之间复制。

''Copying GC 优点：''

优秀的吞吐量： GC 复制算法只搜索并复制活动对象，所以跟一般的 GC 标记 - 清除算法相比，它能在较短时间内完成 GC。也就是说，其吞吐量优秀。

可实现高速分配：GC 复制算法不使用空闲链表。这是因为分块是一个连续的内存空间。因此，调查这个
分块的大小，只要这个分块大小不小于所申请的大小，那么移动 $free 指针就可以进行分配了。

不会发生碎片化：//基于算法性质，活动对象被集中安排在 From 空间的开头对吧。像这样把对象重新集中，放在堆的一端的行为就叫作压缩。//在 GC 复制算法中，每次运行 GC 时都会执行压缩。因此 GC 复制算法有个非常优秀的特点，就是不会发生碎片化。也就是说，可以安排分块允许范围内大小的对象。

''缺点:''

堆使用效率低下 : GC 复制算法把堆二等分，通常只能利用其中的一半来安排对象。也就是说，只有一半堆能被使用。

GC 复制算法必须移动对象重写指针，所以有着跟保守式 GC 算法不相容的性质。