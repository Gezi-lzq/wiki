created: 20230321153842390
creator: Gezi
modified: 20230322021757651
modifier: Gezi
tags: 网络演变
title: 非阻塞IO(NIO)
type: text/vnd.tiddlywiki

! 非阻塞IO(NIO)

[img[NIO(用户态与内核态的调用过程).png]]

1. 用户态调用非阻塞IO系统调用（如 read/write）

2. 内核态立即返回给用户态一个错误码 EWOULDBLOCK，表示数据尚未就绪

3. 用户态轮询（poll/select/epoll_wait）等待文件描述符变为可读/可写

4. 当文件描述符变为可读/可写时，内核态通知用户态进行读写操作

5. 用户态通过系统调用读写数据

6. 内核态将数据从内核缓冲区复制到用户缓冲区，或者将用户缓冲区的数据写入内核缓冲区

7. 用户态收到读写操作结果，可以进行下一步操作。

<<<
阻塞IO和非阻塞IO的主要区别在于<mark class="mark-orange">内核中数据尚未就绪时，如何处理</mark>。

对于''非阻塞IO''，则''直接返回给用户态EWOULDBLOCK错误''；

而''阻塞IO''则一直处于阻塞状态，''直到数据就绪并从内核态拷贝到用户态后才返回''

<<<

!! 优点

将socket设置成非阻塞后，在读取时，如果数据未就绪就直接返回。得益于非阻塞的特性可以通过一个线程管理多个client连接

!! 缺点

需要''不断的轮询询问内核''，数据是否已就绪，涉及很多''无效的，太频繁''的系统调用(system call)

!! 核心矛盾

涉及''很多次无用的、频繁的系统调用''的原因是：非阻塞socket在read时并不知道啥时候数据
会准备好了，所以需要不断''主动询问''。

<<<
使用上次的例子来说，虽然不是一个客人对应一个服务员了，可以一个服务员处理多个客人，但是这个服务员不断的轮流询问客人，是否点菜完了，是否点菜完了，不间断的主动询问，给客人带来了很不好的体验。

于是我们希望，当客人点好菜后，直接呼叫服务员，然后服务员前去处理即可。
<<<

