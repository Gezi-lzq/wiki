created: 20220917135202780
creator: lzq
modified: 20220919070851056
modifier: lzq
tags: 笔记 GMP调度模型
title: GMP调度模型
type: text/vnd.tiddlywiki

# GMP调度模型

三种角色：

* Gorouttine: 用go关键字创建的执行体，它对应一个结构体g，结构体里保存了goroutine的堆栈信息
* Processor: 表示处理器，有了它才能建立G、M的联系
* Machine: 表示操作系统的线程

> 从古至今，多线程的优化有好多种方式，比较常见的一种是reactor模型：
> 线程池中存储大量线程，需要多创建一个线程来执行任务时就从线程池中选取一个线程来用
> 
> Go语言采用的是另一个思路：有几个核就跑几个线程，只是某个线程上面有很多协程；协程的切换是不会像线程切换那样有操作系统层面上的开销的，例如线程切换需要切换虚拟地址空间、切换内核栈、切换硬件上下文、CPUcache需要失效，而切换协程完全没有这些开销。

{{Goroutine}}

{{Machine}}

{{Processor}}

[img[GPM调度.png]]

* 全局队列：存放等待运行的G

* P的本地队列：同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过 256 个。新建 G’时，G’优先加入到 P 的本地队列，如果队列满了，则会把本地队列中一半的 G 移动到全局队列。

* P 列表：所有的 P 都在程序启动时创建，并保存在数组中，最多有 GOMAXPROCS(可配置) 个。

* M：线程想运行任务就得获取 P，从 P 的本地队列获取 G，P 队列为空时，M 也会尝试从全局队列拿一批 G 放到 P 的本地队列，或从其他 P 的本地队列偷一半放到自己 P 的本地队列。M 运行 G，G 执行之后，M 会从 P 获取下一个 G，不断重复下去。