created: 20230804012348683
modified: 20230804065716992
title: RocketMQ client启动流程
type: text/vnd.tiddlywiki

!! Startup

1. Try to fetch route data of topics.


2. Try to get settings from the server, which could do hot-update about these settings. we call this process server-client telemetry.

[img[client-startup-process.png]]

In details, the server-client telemetry provides a channel to upload the local settings and to overwrite the client settings.

```java
// ClientImpl

@Override
protected void startUp() throws Exception {
    log.info("Begin to start the rocketmq client, clientId={}", clientId);
    this.clientManager.startAsync().awaitRunning();
    // Fetch topic route from remote.
    log.info("Begin to fetch topic(s) route data from remote during client startup, clientId={}, topics={}",
        clientId, topics);
    for (String topic : topics) {
        final ListenableFuture<TopicRouteData> future = fetchTopicRoute(topic);
        future.get();
    }
    log.info("Fetch topic route data from remote successfully during startup, clientId={}, topics={}",
        clientId, topics);
    // Update route cache periodically.
    final ScheduledExecutorService scheduler = clientManager.getScheduler();
    this.updateRouteCacheFuture = scheduler.scheduleWithFixedDelay(() -> {
        try {
            updateRouteCache();
        } catch (Throwable t) {
            log.error("Exception raised while updating topic route cache, clientId={}", clientId, t);
        }
    }, 10, 30, TimeUnit.SECONDS);
    log.info("The rocketmq client starts successfully, clientId={}", clientId);
}

private void updateRouteCache() {
    log.info("Start to update route cache for a new round, clientId={}", clientId);
    topicRouteCache.keySet().forEach(topic -> {
        final ListenableFuture<TopicRouteData> future = fetchTopicRoute(topic);
        Futures.addCallback(future, new FutureCallback<TopicRouteData>() {
            @Override
            public void onSuccess(TopicRouteData topicRouteData) {
            }

            @Override
            public void onFailure(Throwable t) {
                log.error("Failed to fetch topic route for update cache, topic={}, clientId={}", topic,
                    clientId, t);
            }
        }, MoreExecutors.directExecutor());
    });
}

private ListenableFuture<TopicRouteData> fetchTopicRoute(final String topic) {
    final ListenableFuture<TopicRouteData> future0 = fetchTopicRoute0(topic);
    final ListenableFuture<TopicRouteData> future = Futures.transformAsync(future0,
        topicRouteData -> onTopicRouteDataFetched(topic, topicRouteData), MoreExecutors.directExecutor());
    Futures.addCallback(future, new FutureCallback<TopicRouteData>() {
        @Override
        public void onSuccess(TopicRouteData topicRouteData) {
            log.info("Fetch topic route successfully, clientId={}, topic={}, topicRouteData={}", clientId,
                topic, topicRouteData);
        }

        @Override
        public void onFailure(Throwable t) {
            log.error("Failed to fetch topic route, clientId={}, topic={}", clientId, topic, t);
        }
    }, MoreExecutors.directExecutor());
    return future;
}

protected ListenableFuture<TopicRouteData> fetchTopicRoute0(final String topic) {
    Resource topicResource = Resource.newBuilder().setName(topic).build();
    final QueryRouteRequest request = QueryRouteRequest.newBuilder().setTopic(topicResource)
        .setEndpoints(endpoints.toProtobuf()).build();
    final RpcFuture<QueryRouteRequest, QueryRouteResponse> future =
        clientManager.queryRoute(endpoints, request, clientConfiguration.getRequestTimeout());
    return Futures.transformAsync(future, response -> {
        final Status status = response.getStatus();
        StatusChecker.check(status, future);
        final List<MessageQueue> messageQueuesList = response.getMessageQueuesList();
        final TopicRouteData topicRouteData = new TopicRouteData(messageQueuesList);
        return Futures.immediateFuture(topicRouteData);
    }, MoreExecutors.directExecutor());
}


```

!! Periodic Task

The client performs same tasks periodically.

[img[client-Periodic-Task.png]]

1. Update topic route data and cache it. The subsequent request could get route from cache directly.

```java
ClientImpl#startUp

// Update route cache periodically.
    final ScheduledExecutorService scheduler = clientManager.getScheduler();
    this.updateRouteCacheFuture = scheduler.scheduleWithFixedDelay(() -> {
        try {
            updateRouteCache();
        } catch (Throwable t) {
            log.error("Exception raised while updating topic route cache, clientId={}", clientId, t);
        }
    }, 10, 30, TimeUnit.SECONDS);
    log.info("The rocketmq client starts successfully, clientId={}", clientId);
```

2. Send heartbeat to keep alive.

```java
ClientManagerImpl#startUp

scheduler.scheduleWithFixedDelay(
    () -> {
        try {
            client.doHeartbeat();
        } catch (Throwable t) {
            log.error("Exception raised during heartbeat, clientId={}", clientId, t);
        }
    },
    HEART_BEAT_INITIAL_DELAY.toNanos(),
    HEART_BEAT_PERIOD.toNanos(),
    TimeUnit.NANOSECONDS
);startUp
```

3. Send server-client telemetry request. Client settings may be overwritten by telemetry response.

```java
ClientManagerImpl#startUp

scheduler.scheduleWithFixedDelay(
    () -> {
        try {
            log.info("Start to log statistics, clientVersion={}, clientWrapperVersion={}, "
                    + "clientEndpoints={}, os description=[{}], java description=[{}], clientId={}",
                MetadataUtils.getVersion(), MetadataUtils.getWrapperVersion(), client.getEndpoints(),
                Utilities.getOsDescription(), Utilities.getJavaDescription(), clientId);
            client.doStats();
        } catch (Throwable t) {
            log.error("Exception raised during statistics logging, clientId={}", clientId, t);
        }
    },
    LOG_STATS_INITIAL_DELAY.toNanos(),
    LOG_STATS_PERIOD.toNanos(),
    TimeUnit.NANOSECONDS
);

scheduler.scheduleWithFixedDelay(
    () -> {
        try {
            client.syncSettings();
        } catch (Throwable t) {
            log.error("Exception raised during the setting synchronization, clientId={}", clientId, t);
        }
    },
    SYNC_SETTINGS_DELAY.toNanos(),
    SYNC_SETTINGS_PERIOD.toNanos(),
    TimeUnit.NANOSECONDS
);
```

!! Message Flow in Producer

The workflow to publish a single message of NORMAL type. The message publishing of other types and publishing of batch messages is similar to it. Some special cases will be explained later.

The publishing procedure is as follows:

[img[message-flow-in-producer.png]]

1. Check if topic route is cached before or not.

```java
protected ListenableFuture<TopicRouteData> getRouteData(final String topic) {
    SettableFuture<TopicRouteData> future0 = SettableFuture.create();
    TopicRouteData topicRouteData = topicRouteCache.get(topic);
    // If route result was cached before, get it directly.
    if (null != topicRouteData) {
        future0.set(topicRouteData);
        return future0;
    }
    inflightRouteFutureLock.lock();
    try {
        // If route was fetched by last in-flight request, get it directly.
        topicRouteData = topicRouteCache.get(topic);
        if (null != topicRouteData) {
            future0.set(topicRouteData);
            return future0;
        }
        Set<SettableFuture<TopicRouteData>> inflightFutures = inflightRouteFutureTable.get(topic);
        // Request is in-flight, return future directly.
        if (null != inflightFutures) {
            inflightFutures.add(future0);
            return future0;
        }
        inflightFutures = new HashSet<>();
        inflightFutures.add(future0);
        inflightRouteFutureTable.put(topic, inflightFutures);
    } finally {
        inflightRouteFutureLock.unlock();
    }
    final ListenableFuture<TopicRouteData> future = fetchTopicRoute(topic);
		....
	}
```

2. If topic route is not cached, then try to fetch it from server, otherwise go to step 4.


3. Return failure and end the current process if topic route is failed to fetch, otherwise cache the topic route and go to the next step.


4. Select writable candicate message queues from topic route to publish meessage.


5. Return failure and end the current process if the type of message queue is not matched with message type.


6. Attempt to publish message.


7. Return success and end the current process if message is published successfully.


8. Catch the error information of failed message publishing.


9. Return failure and end the current process if the attempt times is run out, otherwirse deecide to retry or not according to the error type.


10. Return failure and end the current process if there is no need to retry, otherwise go to the next step.


11. Isolate the current endpoint for publishing.


12. Rotate to next message queue to publish message, and go to step 6.