created: 20241007132831726
creator: Gezi-lzq
modified: 20241009115509509
modifier: Gezi-lzq
tags: 梳理MM2位点翻译流程
title: MM2的位点翻译方案

根据[[预期的位点翻译的效果]]中的前提与效果，当源集群和目标集群之间的消息复制是一一对应的时候，可以通过距离差值将原集群位点映射到目标集群，这样可以保证是绝对准确的。

但是根据[[位点翻译存在哪些挑战]]可知在复制过程中无法保证这个前提，那么如果还按照这个方式去翻译，会是什么效果呢？

答曰：因为翻译后的offset可能在真实对应的offset之前，也能在真实对应的offset之后，所以肯定会丢失消息或者重复消费。

那么如何避免这种现象？

!! 暴力的方案（Dense Cache）

先从暴力的方案去思考，如果存在一个map，记录了源集群到目标集群每个位点的映射，那么翻译的时候只需要从map中取的。
[img[offset_syncs_dense_cache.png]]

!!! 实际可行性分析

假设迁移了10000条消息, 一个 Map（比如 Java 中的 HashMap）来存储 10000 条消息的位点（offset）的映射关系。每个 offset 的大小是 64 位（即 8 字节）。
总大小 = 10000 × 8 × 2 = 160000 字节 = 156.25 KB

但在实际迁移过程中，传输的消息数量远远不止10000条。随着消息数量的增加，Map的大小会迅速膨胀，对内存管理提出巨大挑战。当消息数量足够多时，可能没有设备能够支撑如此大的内存占用。

[img[dense_cache_of_all_offset_syncs.png]]

!! 进行优化（Re-read offset-syncs from topic）

根据刚刚的方案，我们发现把map放到内存里面行不通，那么干脆就每次转换的时候都去从offset-syncs中读取好了，通过持续从Kafka主题中读取偏移量同步信息来进行偏移量的翻译和同步。

[img[Re-read_offset-syncs_from_topic.png]]

优点：

1. 不需要将所有的偏移量映射关系存储在内存中，只需要在需要时从主题中读取。这种方式有效地避免了内存使用随着数据量线性增长的问题。

2. 当需要进行偏移量翻译时，系统可以根据最新的映射关系进行准确的翻译。

缺点：

1. 持续从头到尾读取偏移量同步信息可能会引入一定的延迟，特别是在偏移量同步主题数据量较大的情况下。

2. 尽管减少了内存使用，但偏移量同步主题仍然需要足够的存储空间来保存所有的偏移量同步信息。

由于持续从头到尾读取所有数据会导致显著的延迟，以及在读取过程中占用大量的网络带宽，该方案仍然不具有可行性。
因此需要转变思路，不在倾向于准确的翻译，而是可以接受一些不准确（重复消费）而换来性能上的提升。

!! 继续优化（Dense cache of most recent Offset-Syncs）

最近偏移量同步的密集缓存，这种优化方案的核心思想是仅缓存最近的偏移量同步信息，而不是所有的偏移量同步信息。这样可以在保证一定准确性的前提下，显著减少内存使用。

[img[dense_cache_of_most_recent_offset-syncs.png]]

缓存最近的偏移量同步信息：只缓存最近一段时间内的偏移量同步信息，而不是从头到尾的所有信息。例如，只缓存最近 1000 条消息的偏移量同步信息。但是这种情况下，对于比较早的位点的消息，则不能直接转换，另外我们也很难给出应该保留多近的偏移量同步信息。

高精度翻译：

# 对于消费者滞后（lag）中等和低的消费组，提供高精度的偏移量翻译。
# 对于消费者滞后较高的消费组，无法提供准确的翻译。[[KAFKA-16364|https://issues.apache.org/jira/browse/KAFKA-16364]]

固定缓存大小：

# 需要选择一个在所有情况下都适用的固定缓存大小。
# 缓存大小的选择需要权衡内存使用和翻译精度。

内存使用效率：

# 当偏移量同步信息过于密集时，可能会导致内存使用效率低下。
# 需要确保缓存中的偏移量同步信息足够分散，以提高内存使用效率。

!! 当前方案：Sparse Cache

缓存结构：使用一个固定大小的缓存，存储指数间隔的偏移量同步信息。
[img[Sparse_Cache.png]]
偏移量翻译流程：

# 若当前没有读取完所有的offset sync信息，此时不进行任何转换，直接返回空值。
# 通过latestOffsetSync方法尝试获取该Topic分区中给定offset对应的最新的OffsetSync
## 若给定的upstreamOffset小于OffsetSync对象中的upstreamOffset，那么表示给定的upstreamOffset过于过去，无法准确转换，此时返回-1。
## 若给定的upstreamOffset等于OffsetSync对象中的upstreamOffset，则可直接获得对应位点。
## 若给定的upstreamOffset大于OffsetSync对象中的upstreamOffset，则将获得位点加1作为翻译位点。
## 如果没有找到对应的OffsetSync对象，那么表示无法找到offset的同步信息，此时不进行任何转换，直接返回空值。

[img[稀疏缓存翻译流程.png]]

稀疏缓存方案通过使用指数间隔的偏移量同步信息，能够在保证内存使用非常低的情况下，自适应不同规模的工作负载。虽然对高滞后组的翻译精度较低，但能够优先保证低滞后组的高精度翻译，适用于大多数场景。通过合理的缓存管理策略，可以最大限度地提高系统性能并减少内存占用。

优点

# 内存使用优化：由于只缓存指数间隔的偏移量同步信息，内存使用非常低。
# 自适应工作负载：该方案能够自适应不同规模的工作负载，无需手动调整缓存大小。
# 优先低滞后组：能够优先保证低滞后组的高精度翻译，确保这些组的消息处理效率。

缺点

# 高滞后组精度低：对于滞后较高的消费组，偏移量翻译的精度较低，可能会导致一些消息重复消费。
# 滞后倍增：输出的消费滞后最多是输入滞后的约两倍，可能会影响某些实时性要求较高的应用。

https://github.com/apache/kafka/pull/13429


<<<
https://lists.apache.org/thread/7qzxm1727y8rtrw6ds7t6hltkm55j5po
https://github.com/apache/kafka/pull/13178
<<<